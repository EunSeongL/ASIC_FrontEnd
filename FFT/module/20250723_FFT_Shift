`timescale 1ns / 1ps

module shift_reg #(
    parameter WIDTH = 9,
    parameter DELAY_LENGTH = 16
)(
    input clk,
    input rstn,

    input write, // 16개 묶음 복소수 쓰기
    input read,  // 16개 묶음 복소수 읽기

    input signed [WIDTH-1:0] data_in_real [15:0],
    input signed [WIDTH-1:0] data_in_imag [15:0],

    output logic signed [WIDTH-1:0] data_out_real [15:0],
    output logic signed [WIDTH-1:0] data_out_imag [15:0],

    output logic full,
    output logic empty
);

    reg signed [WIDTH-1:0] shift_din_real [DELAY_LENGTH-1:0][15:0];
    reg signed [WIDTH-1:0] shift_din_imag [DELAY_LENGTH-1:0][15:0];

    reg [$clog2(DELAY_LENGTH+1)-1:0] count;
    integer i, j;

    // full/empty 상태 관리
    assign full  = (count == DELAY_LENGTH);
    assign empty = (count == 0);

    
    // 카운터 업데이트
    always @(posedge clk or negedge rstn) begin
        if (~rstn) begin
            count <= 0;
        end
        else if (write && !read && !full) begin
            count <= count + 1'b1;
        end
        else if (read && !write && !empty) begin
            count <= count - 1'b1;
        end
    end

    // main logic
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            // 초기화
            for (i = 0; i < DELAY_LENGTH; i = i + 1) begin
                for (j = 0; j < 16; j = j + 1) begin
                    shift_din_real[i][j] <= 0;
                    shift_din_imag[i][j] <= 0;
                end
            end
            for (j = 0; j < 16; j = j + 1) begin
                data_out_real[j] <= 0;
                data_out_imag[j] <= 0;
            end
        end else begin
            // read 동작 먼저 수행
            if (read && !empty) begin
                data_out_real <= shift_din_real[DELAY_LENGTH-1];
                data_out_imag <= shift_din_imag[DELAY_LENGTH-1];
            end else begin
                for (j = 0; j < 16; j = j + 1) begin
                    data_out_real[j] <= 0;
                    data_out_imag[j] <= 0;
                end
            end

            // 시프트: read 또는 write 둘 중 하나라도 있으면 시프트
            if ((read && !empty) || (write && !full)) begin
                for (i = DELAY_LENGTH-1; i > 0; i = i - 1) begin
                    shift_din_real[i] <= shift_din_real[i-1];
                    shift_din_imag[i] <= shift_din_imag[i-1];
                end

                if (write && !full) begin
                    shift_din_real[0] <= data_in_real;
                    shift_din_imag[0] <= data_in_imag;
                end else begin
                    for (j = 0; j < 16; j = j + 1) begin
                        shift_din_real[0][j] <= 0;
                        shift_din_imag[0][j] <= 0;
                    end
                end
            end
        end
    end

endmodule










/*`timescale 1ns / 1ps

// 16개 복소수 묶음을 처리하고, Read/Write로 제어하는 FIFO 모듈
module shift_reg #(
    parameter WIDTH = 9,
    parameter DELAY_LENGTH = 16 // 16개 묶음 데이터 블록을 128개 저장 가능
)(
    input clk,
    input rstn,

    input write, // 16개 묶음 복소수 쓰기 활성화 신호
    input read,  // 16개 묶음 복소수 읽기 활성화 신호

    // 16개 복소수의 실수부와 허수부를 각각 묶음으로 입력받는 포트
    input signed [WIDTH-1:0] data_in_real [15:0],
    input signed [WIDTH-1:0] data_in_imag [15:0],
    
    // 16개 복소수의 실수부와 허수부를 각각 묶음으로 출력하는 포트
    output logic signed [WIDTH-1:0] data_out_real [15:0],
    output logic signed [WIDTH-1:0] data_out_imag [15:0],
    
    output logic full,
    output logic empty
);

// 실수부와 허수부를 각각 저장할 2차원 배열
reg signed [WIDTH-1:0] shift_din_real [DELAY_LENGTH-1:0] [15:0];
reg signed [WIDTH-1:0] shift_din_imag [DELAY_LENGTH-1:0] [15:0];
integer i, j;

// FIFO에 저장된 데이터 블록의 개수를 세는 카운터
reg [$clog2(DELAY_LENGTH+1)-1:0] count;

// full, empty 상태 업데이트
always @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        full <= 1'b0;
        empty <= 1'b1;
    end
    else begin
        full <= (count == DELAY_LENGTH) ? 1'b1 : 1'b0;
        empty <= (count == 0) ? 1'b1 : 1'b0;
    end
end

// 카운터 업데이트
always @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        count <= 0;
    end
    else if (write && !read && !full) begin
        count <= count + 1'b1;
    end
    else if (read && !write && !empty) begin
        count <= count - 1'b1;
    end
end

// 16개 묶음 복소수 데이터 처리
always @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        // 리셋 시 모든 레지스터 0으로 초기화
        for(i = 0; i < DELAY_LENGTH; i=i+1) begin
            for(j = 0; j < 16; j=j+1) begin
                shift_din_real[i][j] <= 0;
                shift_din_imag[i][j] <= 0;
            end
        end
        // 출력 포트도 초기화
        for(j = 0; j < 16; j=j+1) begin
            data_out_real[j] <= 0;
            data_out_imag[j] <= 0;
        end
    end
    else begin
        // 쓰기(write)가 활성화되면 16개 묶음 복소수 데이터 입력
        if (write && !full) begin
            // 16개 묶음을 통째로 한 칸씩 시프트 (실수부/허수부 동시)
            for(i = DELAY_LENGTH-1; i > 0; i=i-1) begin
                shift_din_real[i] <= shift_din_real[i-1];
                shift_din_imag[i] <= shift_din_imag[i-1];
            end
            // 새로운 16개 묶음 데이터를 0번 칸에 저장
            shift_din_real[0] <= data_in_real;
            shift_din_imag[0] <= data_in_imag;
        end

        // 읽기(read)가 활성화되면 16개 묶음 복소수 데이터 출력
        if (read && !empty) begin
            // 가장 오래된 16개 묶음 데이터를 출력
            data_out_real <= shift_din_real[DELAY_LENGTH-1];
            data_out_imag <= shift_din_imag[DELAY_LENGTH-1];
            
            // 데이터를 한 칸씩 앞으로 당김 (FIFO 동작)
            for(i = DELAY_LENGTH-1; i > 0; i=i-1) begin
                shift_din_real[i] <= shift_din_real[i-1];
                shift_din_imag[i] <= shift_din_imag[i-1];
            end
            // 맨 앞 칸을 비움
            for(j = 0; j < 16; j=j+1) begin
                shift_din_real[0][j] <= 0;
                shift_din_imag[0][j] <= 0;
            end
        end
        else begin
            // 읽기가 비활성화되면 출력은 0
            for(j = 0; j < 16; j=j+1) begin
                data_out_real[j] <= 0;
                data_out_imag[j] <= 0;
            end
        end
    end
end

endmodule

/* 

`timescale 1ns / 1ps

// FFT 파이프라인의 최상위 모듈 (예시)
module fft_top (
    input clk,
    input rstn,
    // ... 다른 입출력 포트들 ...
);

    // 데이터 비트 폭은 각 단계별로 다를 수 있으므로,
    // module0 다이어그램을 참고하여 적절한 값을 사용해야 합니다.
    // 여기서는 예시로 통일된 비트 폭을 사용합니다.
    localparam DATA_WIDTH = 9;

    // --- 시프트 레지스터 인스턴스화 ---
    
    // Stage 7: 지연 길이 128
    // 입력 데이터의 비트 폭은 9비트 (din <3.6>)
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(128)
    ) sr_128_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage7),
        .data_out(data_out_to_bfly_stage6)
    );

    // Stage 6: 지연 길이 64
    // 이전 스테이지의 출력 비트 폭에 맞춰 WIDTH를 설정합니다.
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(64)
    ) sr_64_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage6),
        .data_out(data_out_to_bfly_stage5)
    );

    // Stage 5: 지연 길이 32
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(32)
    ) sr_32_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage5),
        .data_out(data_out_to_bfly_stage4)
    );

    // Stage 4: 지연 길이 16
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(16)
    ) sr_16_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage4),
        .data_out(data_out_to_bfly_stage3)
    );

    // Stage 3: 지연 길이 8
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(8)
    ) sr_8_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage3),
        .data_out(data_out_to_bfly_stage2)
    );
    
    // Stage 2: 지연 길이 4
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(4)
    ) sr_4_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage2),
        .data_out(data_out_to_bfly_stage1)
    );

    // Stage 1: 지연 길이 2
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(2)
    ) sr_2_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage1),
        .data_out(data_out_to_bfly_stage0)
    );
    
    // Stage 0: 지연 길이 1
    shift_reg #(
        .WIDTH(DATA_WIDTH),
        .DELAY_LENGTH(1)
    ) sr_1_inst (
        .clk(clk),
        .rstn(rstn),
        .data_in(data_in_from_bfly_stage0),
        .data_out(fft_data_out)
    );

endmodule

// FFT 파이프라인의 지연선(Shift Register) 모듈
// 지연 길이를 파라미터로 받아 유연하게 사용 가능
module shift_reg(
    parameter WIDTH = 9,          // 데이터 비트 폭 (예: 9비트) 512
    parameter DELAY_LENGTH = 128  // 지연 길이 (128, 64, 32 등)
)(
    input clk,
    input rstn,

    input signed [WIDTH-1:0] data_in,
    output reg signed [WIDTH-1:0] data_out
);

// 지연 길이에 맞춰 레지스터 배열 선언
reg signed [WIDTH-1:0] shift_din [DELAY_LENGTH-1:0];
integer i;

// 비동기 리셋과 동기 시프트 로직
always@(posedge clk or negedge rstn) begin
    if (~rstn) begin
        // 리셋 시 모든 레지스터 0으로 초기화
        for(i = DELAY_LENGTH-1; i >= 0; i=i-1) begin
            shift_din[i] <= 0;
        end
    end
    else begin
        // 클럭마다 데이터를 한 칸씩 시프트
        for(i = DELAY_LENGTH-1; i > 0; i=i-1) begin
            shift_din[i] <= shift_din[i-1];
        end
        // 새로운 데이터는 배열의 첫 번째 칸으로 들어옴
        shift_din[0] <= data_in;
    end
end

// 지연선의 마지막 값을 출력으로 할당
always @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_out <= 0;
    end
    else begin
        data_out <= shift_din[DELAY_LENGTH-1];
    end
end

endmodule